<!DOCTYPE html>

<html lang="en">

        <head>
                <!-- Page information -->
                <meta charset="UTF-8" />
                <meta name="node_id" content="project design">
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <link rel="shortcut icon" href="/notes/favicon.ico" />

                <!-- Set title -->
                <title>CheerfulP's Notes</title>

                <!-- Includes -->
                <script src="/notes/obs.html/static/obsidian_core.js"></script>
<script src="/notes/obs.html/static/encoding.js"></script>
<link rel="stylesheet" href="/notes/obs.html/static/master.css" />
<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
            'securityLevel': 'loose',
            'theme': 'dark',
            'themeVariables': {
                    'darkMode': true,
            }
    });
</script>
<script>
  MathJax = {
    loader: {
      load: [
        '[tex]/action',
        'output/chtml',
        '[tex]/centernot'
      ]
    },
    tex: {
      inlineMath: [ ["\\(","\\)"] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true,
      processEnvironments: true,
      packages: {'[+]': ['centernot']}
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<script src="/notes/obs.html/static/flexsearch.bundle.js"></script>
<script src="/notes/obs.html/static/pako.js"></script>
<script src="/notes/obs.html/static/search.js"></script>
<script src="/notes/obs.html/static/dirtree.js"></script>




                <!-- Onload tweaks -->
                <script>
                        const CURRENT_NODE = 'project design';
                        const HTML_URL_PREFIX = '/notes';
                        const PAGE_DEPTH = 1;
                </script>
        </head>

<body class="theme-obs-light">
        <div id="antiflash" style="display: none;"></div>
        <script>
                document.getElementById('antiflash').style.display = 'block';
        </script>
        <div id="search-master-div">
    <div id="search-slab" king_ramses="return the slaaab">
            <div id="search-controls">
                    <input id="search_string" placeholder="Type to search notes" type="text" />
                    <div class="tooltip" style="display: none;">
                        <input type="checkbox" id="hard_search" name="hard" />
                        <span class="tooltiptext">Hard search (require exact match)</span>
                    </div>
                    <div id="search-results-box">
                        <div id="search-results"></div>
                    </div>
                    <div id="search-instructions">
                        <div class="prompt-instruction mobile">
                            <button onclick="toggle_id('search-master-div');"><b>Close</b> Search </button>
                        </div>
                    </div>
            </div>
    </div>
</div>

<script>
    document.getElementById("search-master-div").addEventListener('click', e => {
            if(e.target !== e.currentTarget){
                    return
            }
            toggle_id('search-master-div');
    })
    document.getElementById("search_string").addEventListener("input", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    }); 
    document.getElementById("hard_search").addEventListener("click", function(event) {
            setTimeout( () =>run_search('search_string', 'hard_search'), 100 );
    });

    window.addEventListener('keydown', e => {
        if((e.key=='Escape'||e.key=='Esc'||e.keyCode==27)){
            toggle_id('search-master-div');
            return false;
        } 
    }, true);

    function click_list_link(element){
        element.parentElement.getElementsByTagName('a')[0].click()
    }
</script>

        <div id="page_holder" class="flex_col">
                <div id="header" class="header">
    <div id="header_flex" class="flex_row">
            <a href="/notes/index.html" id="homelink" title="Clear screen and go to homepage">CheerfulP's Notes</a>
            <div id="menu_toggle_button" class="navbar-button requires_js" onclick="toggle_menu()">
                    ≡
            </div>
            <div id="navbar" class="navbar requires_js">
                    <a class="navbar-link" href="/notes/index.html" title="Home">Home</a>
<a class="navbar-link" href="/notes/GSOC/GSOC.html" title="GSoC 2024">GSoC 2024</a>
                    <div class="icon-tray">
                            <div id="theme-button" class="theme-button requires_js" title="Change theme" onclick="toggle_theme_popup(this)">
    T
</div>
<script>
    function toggle_theme_popup(el){
        // make theme button show that it's active by adding the .active class
        toggle(el);

        // show the theme selector
        toggle_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            toggle(pu);
        }
    }

    function disable_theme_popup(){
        disable_id('theme-button');

        // show the theme selector
        disable_id('theme-popup')

        let h2 = document.getElementById('header2')
        if (h2){
            let pu = document.getElementById('header2').getElementsByClassName('popup')[0];
            disable(pu);
        }
    }
</script>
                                    <div onclick="openSearch()" class="theme-button requires_js">
            <img src = "/notes/obs.html/static/search.svg" alt="Search notes" title="Search notes" style="margin: 4px;"/>
        </div>
        <script>
            function openSearch(){
                // toggle search popup and continue with extra code if it is enabled this time
                if (toggle_id('search-master-div')){
                    // get input field and temporarily disable it
                    let ss = document.getElementById('search_string');
                    ss.value = 'Seach data initializing...';
                    ss.readOnly = true; 

                    // load search data if not yet done so
                    setTimeout(function(){
                        LoadSearchData()

                        // clear input and put focus on it so that we can start typing immediately
                        ss.value = '';
                        ss.readOnly = false; 
                        ss.focus()
                        ss.select()
                    }, 100);
                }
            }
        </script>
                                    <div class="graph_header_div requires_js">
            <a id="graph_link" class="system-link" href="/notes/obs.html/graph/index.html?node=project design" title="Open fullpage Graph">
                    <img class="graph_header_div_svg" src = "/notes/obs.html/static/graph.svg" alt="Open fullpage Graph" style="margin: 2px; width: 17px;"/>
            </a>
        </div>
                                    <div >
            <a id="dirtree_link" class="system-link" href="/notes/obs.html/dir_index.html" title="View directory tree">
                    <img src = "/notes/obs.html/static/dirtree.svg" style="width: 12px; padding: 4px;" alt="Directory tree link"/>
            </a>
        </div>
                            <div>
    <a href="/notes/obs.html/tags/index.html" title="Open tag view">
            <img src = "/notes/obs.html/static/hashtag.svg" alt="RSS Feed link" style="width: 24px; margin-left: -2px; margin-top: -2px;"/>
    </a>
</div>
                                    <div>
            <a id="rss_link" class="system-link" href="/notes/obs.html/rss/feed.xml" title="RSS Feed link">
                    <img src = "/notes/obs.html/static/rss.svg" alt="RSS Feed link"/>
            </a>
        </div>
                    </div>
                    <div style="display: flex; flex-direction:column">
                        <div id="left_pane_toggle_nav" class="left_pane_toggle_nav">Toggle Directory Tree Pane</div>
                        <div id="right_pane_toggle_nav" class="right_pane_toggle_nav">Toggle Table of Contents Pane</div>
                    </div>
            </div>
    </div>
    <div class="popup" id="theme-popup">
    <label for="cars">Theme </label>

    <select name="theme" id="theme" onchange="set_theme(this.value)">
      <option value="obs-light" selected="selected">obsidian-light</option>
      <option value="obs-dark">obsidian-dark</option>
    </select> 
</div>
</div>
                <div class="flex_row">
                        <div id="left_pane" class="left_pane active">
    <div id="left_pane_fold_header" class="left_pane_fold_header fold_header">x</div>
    <div id="left_pane_content" class="left_pane_content">
            <div id="dirtree"><button id="folder-1" class="dir-button active" onclick="toggle_dir(this.id)"><div class="file-icon"></div>GSOC</button>
<div id="folder-container-1" class="dir-container requires_js active" path="/notes/GSOC">
	<ul class="dir-list">
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSOC.html"  >GSOC</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSoC Changelog.html"  >GSoC Changelog</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSoC Devlog (August).html"  >GSoC Devlog (August)</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSoC Devlog (July).html"  >GSoC Devlog (July)</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSoC Devlog (June).html"  >GSoC Devlog (June)</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GSoC Devlog (May).html"  >GSoC Devlog (May)</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/GsoC Research Links.html"  >GsoC Research Links</a></li>
		<li><div class="file-icon"></div><a class="active current_page_dirtree" href="/notes/GSOC/Project Design.html"  >Project Design</a></li>
		<li><div class="file-icon"></div><a class="" href="/notes/GSOC/Project Motivation.html"  >Project Motivation</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/GSOC/Waycrate_GSOC_2024.pdf"  class="external-link">Waycrate_GSOC_2024.pdf</a></li>
	</ul>
</div>
<button id="folder-2" class="dir-button " onclick="toggle_dir(this.id)"><div class="file-icon"></div>_attachments</button>
<div id="folder-container-2" class="dir-container requires_js " path="/notes/_attachments">
	<ul class="dir-list">
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/Pasted image 20240619212710.png"  class="external-link">Pasted image 20240619212710.png</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/Pasted image 20240730174837.png"  class="external-link">Pasted image 20240730174837.png</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/Pasted image 20240730180003.png"  class="external-link">Pasted image 20240730180003.png</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/Pasted image 20240730180043.png"  class="external-link">Pasted image 20240730180043.png</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/proposal_image1.png"  class="external-link">proposal_image1.png</a></li>
		<li><div class="file-icon non-md-file"></div><a class="" href="/notes/_attachments/wayshot-2024_05_14-18_34_28.png"  class="external-link">wayshot-2024_05_14-18_34_28.png</a></li>
	</ul>
</div>
<ul class="dir-list">
	<li><div class="file-icon"></div><a class="" href="/notes/index.html"  >index</a></li>
</ul>
</div>
    </div>
</div>
                        <div class="container">
                                <div class="content"><h1 id="project-design">Project Design</h1>
<div class="toc">
<ul>
<li><a href="#project-design" class="anchor-link">Project Design</a><ul>
<li><a href="#protocol-selection" class="anchor-link">Protocol Selection</a></li>
<li><a href="#design" class="anchor-link">Design</a><ul>
<li><a href="#obtaining-a-gpu-handle" class="anchor-link">Obtaining A GPU handle</a></li>
<li><a href="#finding-parameters-to-be-used-for-the-dma-buf" class="anchor-link">Finding parameters to be used for the DMA-BUF</a></li>
<li><a href="#dma-buf-backed-wl-buffer-creation" class="anchor-link">DMA-BUF Backed wl-buffer Creation</a></li>
<li><a href="#passing-the-wl-buffer-to-compositor-for-copy" class="anchor-link">Passing the wl-buffer to compositor for copy</a></li>
<li><a href="#returning-the-resulting-buffer-to-the-library-user" class="anchor-link">Returning the resulting buffer to the library user</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="protocol-selection">Protocol Selection</h2>
<p>First, we need some context around how wlroots-based wayland compositors handle screen capture. There are mainly two protocols that enable this: <br />
1.  wlr-screencopy-unstable-v1 <br />
2.  wlr-export-dmabuf-unstable-v1   </p>
<p>Libwayshot in its present state uses only wlr-screencopy. The major difference between these two is in the type of buffers each of them deal with:   </p>
<ul>
<li>In wlr-screencopy the compositor will notify the client of upto two different types of available buffer types: wl_shm shared memory buffers and linux dmabuf based DMA-BUF buffers. The client must create one of these and pass it to the compositor for it to copy screen content into.   </li>
<li>libwayshot presently uses only the wl_shm mode of wlr-screencopy.   </li>
<li>wlr-screencopy is capable of copy on damage functionality: the compositor signals a filled buffer only when the captured region has been damaged.   </li>
<li>wlr-screencopy can choose to capture certain sub-regions of outputs.   </li>
<li>
<p>Buffers here must be created by the client: wl_shm buffers can be created by memfd_create and dmabuf buffers can be created by the linux_dmabuf wayland protocol.   </p>
</li>
<li>
<p>A copy is unavoidable here. However, VRAM-&gt;CPU copies can still be avoided in dmabuf mode as dmabuf buffer copies occur entirely on the GPU. These are relatively more efficient depending on the hardware and drivers.   </p>
</li>
<li>
<p>wlr-export-dmabuf deals solely with dmabuf buffers. In this protocol the compositor passes off dmabuf handles to the client for each frame. No copying will be involved here.   </p>
</li>
<li>
<p>The client can choose which output to capture but it cannot select regions under this output.   </p>
</li>
<li>No copy with damage is available.   </li>
<li>The client need not create dmabuf buffers of its own.   </li>
</ul>
<p>Overall the tradeoffs between these approaches are as follows:   </p>
<ul>
<li>wlr-screencopy needs to perform dmabuf copies but these are pretty efficient and any performance losses here compared to wlr-export-dmabuf here should be somewhat offset by the availability of copy with damage requiring less data to be processed overall. Ultimately benchmarking will be required to understand the performance gaps.   </li>
<li>
<p>wlr-screencopy is more complex to implement than wlr-export-dmabuf but this is offset by the fact that most of this complexity is already present in libwayshot while wlr-export-dmabuf will have to be implemented from scratch.   </p>
</li>
<li>
<p>The overall trade off appears to be between the flexibility and universal availability of wlr-screencopy versus the simplicity and (arguably) performance of wlr-export-dmabuf.   </p>
</li>
</ul>
<p>After consideration of the above tradeoffs and discussion with organization contributors, I have decided to implement the wlr-screencopy version of the dmabuf backend for this project.   </p>
<h2 id="design">Design</h2>
<p>Here’s a diagram containing high level overview of what I propose to initially build. The components in dotted lines will be implemented as part of GSoC. <br />
<img alt="" src="/notes/_attachments/proposal_image1.png" />   </p>
<p>The main steps in implementing this are: <br />
1. Obtaining a GPU Handle <br />
2. Finding parameters to be used for the dmabuf object <br />
3. dmabuf backed wl-buffer creation <br />
4. Passing the wl-buffer to compositor for copy <br />
5. Returning the resulting buffer to the library user   </p>
<p>Let’s have a high-level overview for each of these steps:   </p>
<h3 id="obtaining-a-gpu-handle">Obtaining A GPU handle</h3>
<p>For creating a dmabuf, we need a DRM render node to create it on.  <br />
I plan to use <a href="https://crates.io/crates/drm" class="external-link">drm-rs</a> , bindings for libdrm, for this purpose. This library, belonging to the Smithay project also has a sister library <a href="https://crates.io/crates/gbm" class="external-link">GBM crate</a> which can be used to create backing dmabufs for wayland-rs's dmabuf object.   </p>
<p>drm-rs requires a file name to the render node in order to open it, usually located in <code>/dev/dri</code>:   </p>
<blockquote>
<p>$ &gt; la /dev/dri <br />
total 0 <br />
drwxr-xr-x  2 root root         80 May 24 10:16 by-path/ <br />
crw-rw----+ 1 root video  226,   1 May 24 20:15 card1 <br />
crw-rw-rw-  1 root render 226, 128 May 24 10:16 renderD128   </p>
</blockquote>
<p>There are a few ways to obtain the render node path:   </p>
<ul>
<li>From the user: the user can pass the path as an string argument   </li>
<li>Using the <a href="https://wayland.app/protocols/drm-lease-v1#wp_drm_lease_request_v1" class="external-link">drm-lease-v1 protocol</a> , this protocol can be used to lease a DRM device for high performance purposes.   </li>
<li>Fallback to /dev/renderD128 if drm-lease protocol is unavailable   </li>
</ul>
<p>Once we have a drm-rs <code>Card</code> object available, we're ready to create a DMA-BUF on it via GBM. Create a <code>GBMDevice</code> using the <code>Card</code> object. All of this can be done when the <code>WayshotConnection</code> object is initialized and the <code>GBMDevice</code> object can be stored in that struct.   </p>
<h3 id="finding-parameters-to-be-used-for-the-dma-buf">Finding parameters to be used for the DMA-BUF</h3>
<p>The key data structure that deals with individual frames in libwayshot is the <code>CaptureFrameState</code> struct. It is this struct that interacts with the wayland-rs screencopy API to capture individual frames. Here's how each frame capture happens:   </p>
<ul>
<li>The <code>capture_output_frame_get_state</code> function in <code>WayshotConnection</code> initializes a <a href="https://wayland.app/protocols/wlr-screencopy-unstable-v1#zwlr_screencopy_manager_v1" class="external-link">screencopy_manager</a> with appropriate region selection parameters and then uses it to create a CaptureFrameState struct along with an associated <a href="https://wayland.app/protocols/wlr-screencopy-unstable-v1#zwlr_screencopy_frame_v1" class="external-link">screencopy frame</a>   </li>
<li>The wayland-rs <code>Dispatch</code> implementation for <code>CaptureFrameState</code> in <code>dispatch.rs</code> listens for a <code>buffer</code> event that contains information that can be used to create a <a href="https://wayland.app/protocols/wayland#wl_shm" class="external-link">wl_shm</a> object to be passed to the compositor for it to copy the frame data into.   <ul>
<li>This includes things like frame height, frame width, stride and the fourcc color format for the buffer.   </li>
<li>For our project, we'll also have to listen for <code>linux_dmabuf</code> events that do the same thing for dmabufs.   </li>
</ul>
</li>
<li>The function <code>capture_output_frame_inner</code> is what initializes the <code>wl_shm</code> buffer and calls the screencopy <a href="https://wayland.app/protocols/wlr-screencopy-unstable-v1#zwlr_screencopy_frame_v1:request:copy" class="external-link">copy</a> request to ask the compositor to copy the frame into the buffer.   <ul>
<li>For our project, we'll instead have to create a dmabuf object on the GPU we initialized earlier and pass that instead. This is detailed next.   </li>
</ul>
</li>
</ul>
<h3 id="dma-buf-backed-wl-buffer-creation">DMA-BUF Backed wl-buffer Creation</h3>
<p>Creating a DMA-BUF is a somewhat more involved process than creating shm buffers. While the latter can be created using a few system calls, the general mechanism for creating DMA-BUFs in wayland is by using the stable linux-dmabuf protocol.   </p>
<p>The general steps involved are:   </p>
<ul>
<li>Obtain the ZwpLinuxDmabufV1 interface from the compositor.   <ul>
<li>The wayland global registry can be queried to do this.   </li>
</ul>
</li>
<li>Use ZwpLinuxDmabufV1 to create a ZwpLinuxBufferParamsV1 interface object.   <ul>
<li>Relevant request: <a href="https://wayland.app/protocols/linux-dmabuf-v1#zwp_linux_dmabuf_v1:request:create_params" class="external-link">create_params</a>   </li>
</ul>
</li>
<li>Use the ZwpLinuxBufferParamsV1 interface to build a dmabuf backed wl-buffer:   <ul>
<li>Use the frame parameters obtained earlier from screencopy's <code>linux_dmabuf</code> event to create a GBM buffer object (<code>create_buffer_object</code>)   </li>
<li>Get a file descriptor to the buffer object and pass it to the ZwpLinuxBufferParamsV1 object's add method to connect the wayland object to it's backing buffer   </li>
<li>Use the <a href="https://wayland.app/protocols/linux-dmabuf-v1#zwp_linux_buffer_params_v1:request:create_immed" class="external-link">create_immed</a>method to immediately initialize a wl_buffer object.   </li>
</ul>
</li>
</ul>
<h3 id="passing-the-wl-buffer-to-compositor-for-copy">Passing the wl-buffer to compositor for copy</h3>
<p>Once the requisite wl-buffer has been created a handle to it needs to be passed to the compositor so that the compositor can fill it in. The steps for this are:   </p>
<ul>
<li>Create the dmabuf backed wl-buffer using the linux-dmabuf protocol as discussed above.   </li>
<li>Pass the dmabuf backed wl-buffer to the compositor to be filled in. libwayshot already does this with the copy request on the ZwlrScreencopyFrameV1 interface. The process is the same for dmabuf backed wl-buffers.   </li>
</ul>
<h3 id="returning-the-resulting-buffer-to-the-library-user">Returning the resulting buffer to the library user</h3>
<p>Once the copy is complete libwayshot has to pass the resultant screenshot to the caller in a usable form. This can be done by returning one or all of the following objects:   </p>
<ul>
<li>GBM Buffer Objects   </li>
<li>wayland-rs wl-buffer   </li>
<li>An EGL Image, this will add additional dependencies to the library but will add more flexibility to what can be done with the buffers.    </li>
</ul>
<div class="callout callout-question active" rasa="1">
<div class="callout-title ">
<div class="callout-title-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="callout-icon"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
</div>
<div class="callout-title-name">What is EGL? <br />
</div>
</div>
<div class="callout-content">
<p>From the <a href="http://www.khronos.org/registry/egl/specs/eglspec.1.5.pdf" class="external-link">EGL specification</a> "EGL [is] an interface between rendering APIs such as OpenCL, OpenGL, OpenGL ES or OpenVG (referred to collectively as client APIs) and one or more underlying platforms (typically window systems such as X11)" (or in our case - Wayland)</p>
</div>
</div>
<ul>
<li>A OpenGL texture. This can be obtained from the EGLImage, bound to the GL context and can then be rendered on screen.   </li>
</ul></div>
<div class="note-footer">
<div class="backlinks">
<h2>Backlinks</h2>
<ul>
	<li><a class="backlink" href="/notes/GSOC/GSoC Devlog (May).html">gsoc devlog (may)</a></li>
	<li><a class="backlink" href="/notes/GSOC/GSOC.html">gsoc</a></li>
</ul>
</div>

<div class="tags">
<h2>Tags</h2>
<ul>
	<li><a class="backlink" href="/notes/obs.html/tags/gsoc/index.html">gsoc</a></li>
</ul>
</div>

</div>
<div class="graph requires_js ">
    <div id="A202311622314622874324146258530780056834{level}" class="graph_div"></div>

    <div class="graph-instructions" id="D202311622314622874324146258530780056834{level}">
        Left-click: follow link, Right-click: select node, Scroll: zoom
    </div>
    
    <div class="graph-button-row" style="display:flex;">
        <button class="graph_button graph_show_button" id="B202311622314622874324146258530780056834{level}" level="{level}" note_temp_id="202311622314622874324146258530780056834" onclick="window.ObsHtmlGraph.run(this, '202311622314622874324146258530780056834', 'project design');">
            Show Graph
        </button>
        <button class="graph_button graph_type_button" id="C202311622314622874324146258530780056834{level}" style="flex:1" onclick="window.ObsHtmlGraph.switch_graph_type(this);">
            2D
        </button>
    </div>
</div>

<script type="module">
    if (window.ObsHtmlGraph == undefined){
        import('/notes/obs.html/static/graph.js').then((Module) => {
            window.ObsHtmlGraph = Module;
            window.ObsHtmlGraph.arm_page(document.getElementById('page_holder'))
        })
    }
</script>




                                <!-- end content -->
                        </div>
                        <div class="container_filler">
                        </div>
                        <div id="right_pane" class="right_pane active">
    <div id="right_pane_fold_header" class="right_pane_fold_header fold_header">x</div>
    <div id="right_pane_content" class="right_pane_content">
            
    </div>
</div>
                </div>
        </div>

        <script>
                function handle_toggle_side_bar(e){
                        let header;
                        let pane; 
                        let target = e.target

                        // switch out the navbar button click for a header click
                        if (target.id == 'left_pane_toggle_nav'){
                                target = document.getElementById('left_pane_fold_header')
                        }
                        else if (target.id == 'right_pane_toggle_nav'){
                                target = document.getElementById('right_pane_fold_header')
                        }

                        // get header and pane
                        if (target.classList.contains('fold_header')) {
                                header = target;
                                pane = target.parentElement;
                        }
                        else {
                                pane = target;
                                header = target.getElementsByClassName('fold_header')[0];
                        }
                        toggle_side_bar(pane, header, true)
                        e.stopPropagation();
                }
                function handle_toggle_side_bar_button(e){
                        document.getElementById('menu_toggle_button').click()
                        handle_toggle_side_bar(e);
                }

                function toggle_side_bar(pane, header, save) {
                        let active = (pane.classList.contains('active'))
                        if (active){
                                disable_side_bar(pane, header, save);
                        }
                        else {
                                enable_side_bar(pane, header, save);
                        }
                }
                function enable_side_bar(pane, header, save){
                        pane.classList.add('active');
                        pane.removeEventListener('click', handle_toggle_side_bar);
                        header.addEventListener('click', handle_toggle_side_bar);
                        set_correct_header_symbol(header);
                        if (save){ save_panel_folding_state(header, true) }
                }
                function disable_side_bar(pane, header, save){
                        pane.classList.remove('active');
                        pane.addEventListener('click', handle_toggle_side_bar);
                        header.removeEventListener('click', handle_toggle_side_bar);
                        set_correct_header_symbol(header);
                        if (save){ save_panel_folding_state(header, false) }
                }
                function set_correct_header_symbol(header){
                        let pane = header.parentElement;
                        let symbol = [['>', '<'],['<', '>']]
                        symbol = symbol[Number(header.classList.contains('right_pane_fold_header'))][Number(pane.classList.contains('active'))];
                        console.log(symbol);
                        header.innerHTML = symbol
                        return header;
                }
                function panel_folding_get_panel_name(header){
                        return ['left', 'right'][Number(header.classList.contains('right_pane_fold_header'))]
                }
                function save_panel_folding_state(header, active){
                        ls_set('pane_folding_state_'+panel_folding_get_panel_name(header), Number(active));
                }
                function load_panel_folding_state(panel_name){
                        val = ls_get('pane_folding_state_'+panel_name)
                        if (!val){ return {'exists': false, 'value': null}}
                        return {'exists': true, 'value': Boolean(Number(val))}
                }
                function set_pane_folding_start(left_header, right_header){
                        // small screen = closed
                        let right_pane_enabled = true;
                        let left_pane_enabled = true;
                        let w = window.visualViewport.width
                        if (w < 1000){
                                left_pane_enabled = false
                        }
                        if (w < 800){
                                right_pane_enabled = false
                        }

                        // get saved values if present
                        let rval = load_panel_folding_state('right')
                        if (rval['exists']){
                                right_pane_enabled = rval['value']
                        }
                        let lval = load_panel_folding_state('left')
                        if (lval['exists']){
                                left_pane_enabled = lval['value']
                        }

                        // default = enabled, so we only need to disable
                        if (!left_pane_enabled){
                                disable_side_bar(document.getElementById('left_pane'), document.getElementById('left_pane_fold_header'))
                        }
                        if (!right_pane_enabled){
                                disable_side_bar(document.getElementById('right_pane'), document.getElementById('right_pane_fold_header'))
                        }
                }

                function init_pane_folding(header){
                        set_correct_header_symbol(header);
                        header.addEventListener('click', handle_toggle_side_bar);
                }
                
                
                set_pane_folding_start()
                init_pane_folding(document.getElementById('left_pane_fold_header'));
                init_pane_folding(document.getElementById('right_pane_fold_header'));

                document.getElementById('left_pane_toggle_nav').addEventListener('click', handle_toggle_side_bar_button);
                document.getElementById('right_pane_toggle_nav').addEventListener('click', handle_toggle_side_bar_button);
        </script>

        <script src="/notes/obs.html/static/load_dirtree_footer.js" type="text/javascript"></script>

        




</body>
</html>
